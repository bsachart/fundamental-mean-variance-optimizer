# Hybrid Quantamental Optimizer

> **Modern Portfolio Theory evolved for the fundamental investor.**

A portfolio construction engine that fixes the "rear-view mirror" bias of traditional MPT by explicitly decoupling forward-looking return forecasting, risk modeling, and mathematical optimization.

---

## 1. Project Overview

Traditional MPT relies on historical returns to predict the future. This is fundamentally backward-looking and fails during regime changes.

**Our Approach**: Treat return forecasting, risk modeling, and optimization as three independent problems:

1.  **Return Engine**: Generate forward-looking expected returns (Fundamental CAGR).
2.  **Risk Engine**: Model covariance using forward-looking volatility (Implied Vol).
3.  **Optimization Engine**: Find optimal weights given $\mu$ and $\Sigma$.

**Web Interface**: A graphical interface for this engine is available at: [LINK_PLACEHOLDER]

---

## 2. Quick Start

### Step 1: Generate Data
A utility script is provided to fetch historical prices and compute fundamental metrics.

```bash
# Generates historical_prices.csv and asset_metrics.csv
python src/data/generate_universe.py
```

### Step 2: Run Optimization

```python
from portfolio import PortfolioEngine

# Initialize engine
engine = PortfolioEngine()

# Load data (automatically validates and aligns)
engine.load_prices("historical_prices.csv")
engine.load_metrics("asset_metrics.csv")

# A. Optimize for a specific volatility target (Capital Market Line)
portfolio = engine.optimize(
    risk_model="forward-looking", 
    target_volatility=0.15,       # 15% Annual Volatility
    risk_free_rate=0.04           # 4% Risk-Free Rate
)

# B. Optimize for the Tangency Portfolio (Max Sharpe)
# (Occurs if target_volatility is not provided)
tangency = engine.optimize(risk_model="forward-looking")

# C. Generate Efficient Frontier Points
# (Pass a list of volatilities)
frontier = engine.optimize(target_volatility=[0.10, 0.15, 0.20])

# Analyze results
print(portfolio.summary())
portfolio.plot()
```

---

## 3. Data Specifications

The engine requires two specific CSV files. 

### A. Price History (`historical_prices.csv`)
Used to calculate correlation matrices.

*   **Format**: Time-series.
*   **Columns**: `date` (YYYY-MM-DD), followed by one column per ticker.

```csv
date,AAPL,GOOG,TSLA
2023-01-31,150.23,105.44,250.67
2023-02-28,152.11,108.22,255.33
```

### B. Asset Metrics (`asset_metrics.csv`)
Used for $\mu$ (Expected Returns) and diagonal $\Sigma$ (Volatilities). This file is generated by the provided Python script.

*   **Format**: Cross-sectional.
*   **Units**: **Decimals/Base** (e.g., 0.12 = 12%).

```csv
ticker,expected_return,implied_volatility,min_weight,max_weight
AAPL,0.12,0.25,0.0,1.0
GOOG,0.15,0.28,0.0,1.0
TSLA,0.03,0.10,-1.0,0.0
```

| Column | Description | Required For |
| :--- | :--- | :--- |
| `ticker` | Symbol matching price CSV | All |
| `expected_return` | Annualized expected return (Decimal) | All |
| `implied_volatility` | Forward-looking annual vol (Decimal) | `risk_model="forward-looking"` |
| `min_weight` | Minimum allocation (0.0 = long only) | All |
| `max_weight` | Maximum allocation (1.0 = no leverage) | All |

---

## 4. Methodology: Return Models ($\mu$)

We prioritize fundamental derivation over historical extrapolation.

### Fundamental Implied CAGR (The "Business Model")

We model returns by simulating the business fundamentals $N$ years into the future.

**1. Linear Margin Ramp**  
The model interpolates a path from the current Net Profit Margin (NPM) to a target Terminal NPM.
$$NPM_t = NPM_{start} + \frac{t}{N} (NPM_{terminal} - NPM_{start})$$

**2. Sales Growth (Self-Funding)**  
Profitable companies reinvest earnings. We treat NPM as fuel for top-line expansion.
$$Sales_t = Sales_{t-1} \times (1 + \text{OrganicGrowth} + NPM_{t-1})$$
*Note: Organic Growth includes effects like SBC but excludes buybacks.*

**3. Terminal Valuation & Implied Return**  
$$MC_{\text{exit}} = Sales_N \times NPM_N \times PE_{\text{exit}}$$
$$\mu = \left(\frac{MC_{\text{exit}}}{MC_{\text{current}}}\right)^{1/N} - 1$$

---

## 5. Methodology: Risk Models ($\Sigma$)

### Option A: Historical Covariance
Classic MPT approach using the sample covariance of historical returns.
```python
risk_model="historical"
```

### Option B: Hybrid Implied Volatility (Recommended)
Combines the **structure** of the past with the **magnitude** of the future.

*   **Correlations ($\rho$)**: Derived from `historical_prices.csv` (Assets usually maintain structural relationships, e.g., Tech moves with Tech).
*   **Volatility ($\sigma$)**: Derived from `asset_metrics.csv` (IV, representing the market's forward-looking fear).

**Formula:**
$$\Sigma_{ij} = \rho_{ij}^{\text{historical}} \times \sigma_i^{\text{implied}} \times \sigma_j^{\text{implied}}$$

This creates a covariance matrix where the diagonal is the Options Market IV, but the off-diagonal elements respect historical correlations.

```python
risk_model="forward-looking"
```

---

## 6. Methodology: Optimization

The solver uses `cvxpy` to perform Mean-Variance Optimization.

### The Objective
Maximize the Sharpe Ratio:
$$\text{maximize} \frac{w^T \mu - R_f}{\sqrt{w^T \Sigma w}}$$

Subject to:
1.  $\sum w_i = 1$
2.  $w_{\min} \leq w_i \leq w_{\max}$

### Capital Market Line (CML) Allocation
If a `target_volatility` is provided, the engine:

1.  Solves for the **Tangency Portfolio** (Max Sharpe).
2.  Allocates between the Tangency Portfolio and Cash ($R_f$) to hit the exact target volatility $\sigma_p$.

$$w_{\text{risky}} = \frac{\sigma_p}{\sigma_{\text{tangency}}}$$
$$w_{\text{cash}} = 1 - w_{\text{risky}}$$



